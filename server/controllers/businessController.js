// controllers/businessController.js
import Business from '../models/businessSchema.js';
import { getWeekRange } from '../utils/getWeekRange.js'; // Import the utility function

// Controller function to handle creating a new business document
export const addBusiness = (req, res) => {
    const { weekStartDate, weekEndDate } = getWeekRange(new Date()); // Get the start and end date of the week

    // Using the mongoose constructor to create the business object and assign the according attributes
    // req.body is an object that contains data sent by the client in the body of a request, typically in POST, PUT, or PATCH requests.
    // For example, if a client sends a JSON payload or form data to the server, it will be accessible in req.body
    // In this example - req.body.businessCode - req.body.businessCode refers to the businessCode attribute of the object.
    // Therefore, if the input in the businessCode input field is "1234", req.body.business would be equal to "1234"
    // The same function applies to each of the attribute of the object
    const business = new Business({
        businessCode: req.body.businessCode,
        weekStartDate,  // Generated by the getWeekRange function
        weekEndDate,  // Generated by the getWeekRange function
        totalBookings: req.body.totalBookings,
        occupancyRate: req.body.occupancyRate,
        cancellationRate: req.body.cancellationRate,
        bookingLeadTime: req.body.bookingLeadTime,
        noShowRate: req.body.noShowRate,
        revenuePerBooking: req.body.revenuePerBooking,
        bookingConversionRate: req.body.bookingConversionRate,
        averageBookingValue: req.body.averageBookingValue,
        paymentStatus: req.body.paymentStatus,
        costPerBooking: req.body.costPerBooking,
        customerRetentionRate: req.body.customerRetentionRate,
        seasonalBookingTrends: req.body.seasonalBookingTrends,
        demandForecasting: req.body.demandForecasting,
        revenueForecasting: req.body.revenueForecasting
    });

    // Saving the business to the MongoDB database
    business.save()
        // Once the data is saved, the business information is then sent to the frontend
        .then((result) => res.json(result))
        // If an error occurs, the errors will be output into the console,
        // and the according server status code is set (500 = internal server error)
        .catch((err) => {
            console.log('Error saving business', err);
            res.status(500).send('Error saving business')
        });
};

// The graph data fetching will need to be modified to allow for multiple business documents to be found
// The data fetching algorithm will use weeks data value on each point of the graph, this will be used to smoothen out the data
// Maybe used fetchMultiple() ? and the iterate through each element of the array to add data to the graphs

//export const getGraphData = (req, res) => {
    // This API is used to fetch data from the database.
    // The algorithm currently has a manual input for which business data to find,
    // but eventually, the program will send the business code
   // Business.find( { businessCode: "BIZ124" })
      //  .then((result) => res.send(result))
     //   .catch((err) => {
       //     console.log('Error saving business', err);
     //       res.status(500).send('Error fetching business data')
       // });
//}

export const getGraphData = async (req, res) => {
    try {
        // Using MongoDB aggregation to fetch multiple documents and then map each metric data into a separate array
        // This will allow my program to easily visualise the data
        // Additionally, I have included the weekStartDate and weekEndDate as I may use this within the axis of the graph
        // This structure is useful when trying to show the weekly periods alongside their metrics in the response
        // filtering between dates can be included within the aggregation search, but I haven't included this feature within the current algorithm.
        // This feature would require further UI additions, which may be unfeasible within my NEA time frame.
        const metrics = await Business.aggregate([
            { $match: { businessCode: req.session.user.businessCode} }, // filter by business
            { $sort: { weekStartDate: 1 } }, // Sorted by weekStart date (the value is stored in the business document)
            {
                $group: {
                    _id: null,
                    metricData: {
                        $push: {
                            weekStartDate: "$weekStartDate",
                            weekEndDate: "$weekEndDate",
                            totalBookings: "$totalBookings",
                            occupancyRate: "$occupancyRate",
                            cancellationRate: "$cancellationRate",
                            bookingLeadTime: "$bookingLeadTime",
                            noShowRate: "$noShowRate",
                            revenuePerBooking: "$revenuePerBooking",
                            bookingConversionRate: "$bookingConversionRate",
                            averageBookingValue: "$averageBookingValue",
                            paymentStatus: "$paymentStatus",
                            costPerBooking: "$costPerBooking",
                            customerRetentionRate: "$customerRetentionRate",
                            seasonalBookingTrends: "$seasonalBookingTrends",
                            demandForecasting: "$demandForecasting"
                        },
                    },
                },
            },
        ]);

        // Check if data exists
        if (!metrics || metrics.length === 0) {
            return res.status(404).json({
                message: 'No metrics found.',
                success: false,
            });
        }

        // Send the 'metricData' array to the frontend
        res.status(200).json({
            success: true,
            // the aggregation returns an array with one object because _id: null groups all documents into a single group
            // metrics[0] accesses that single object
            // metrics[0].metricData contains the array of weekly data that you want to send to the frontend
            data: metrics[0].metricData, // Extract 'metricData' from the first (and only) element
        });

    } catch (error) {
        console.error("Error fetching graph data", error)
        res.status(500).json({
            message: 'Failed to fetch graph data',
            success: false
        });
    }
};

export const getWeeklyData = (req, res) => {
    // Defining the conditions, the business document must match the Code, weekStartDate and weekEndDate.
    // If found, the businesses weekly document will be returned
    Business.find({
        businessCode: "BIZ123",
        weekStartDate: "2024-11-10",
        weekEndDate: "2024-11-16"
    })
    .then((result) => res.send(result))
    .catch((err) => {
        console.log('Error saving weekly data', err);
        res.status(500).send('Error fetching weekly data')
    });
}